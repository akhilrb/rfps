#include <SPI.h>        //will control a shift register for VFX
#include <Wire.h>       //Using I2C
#include <eeprom.h>     //In game changes like the number of hits can be stored on the EEPROM. Turning off the Arduino will keep the score saved.
#include <Adafruit_SSD1306.h>   //Controlling OLED screen
#include <Adafruit_GFX.h>       //Refer to actual documentation
#include "template.h"   //contains the template of the basic screen. Components that don't change on the screen or their default values are fed in the template bitmap
#include "frame.h"      //sources the template and makes it dynamic
#include "hexmap.h"     //stores a custom hexmap. generated by the BitConverter python module

#define leds 9  //basic VFX will be good I suppose
#define sck 13  //always keep latch activated, no need for a different pin
#define trig 0  //interrupt pin 2 on uno; trigger button
#define ir_tx 5 //IR transmission LED
#define ir_rx 1 //interrupt pin 3 on uno; IR reception LED (the "tag")

#define _height 64
#define _width 128

volatile unsigned int health, ammo;
volatile bool alive;

SPISettings custom(48000000, LSBFIRST, SPI_MODE0);
volatile byte ledStatus = 0b00010000;    //store 8 LED states as 1 byte
/*
following LSB order:
0: shoot
1: reload
2: hit
3: dead
4: alive
5: team colour B    can be used if we include team concept
6: team colour G
7: team colour R
*/

class elapsedMillis     //creates objects whose values are automatically incremented every millisecond; millis() not required
{
private:
    unsigned long ms;
public:
    elapsedMillis(void) { ms = millis(); }
    elapsedMillis(unsigned long val) { ms = millis() - val; }
    elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
    operator unsigned long () const { return millis() - ms; }
    elapsedMillis & operator = (const elapsedMillis &rhs) { ms = rhs.ms; return *this; }
    elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
    elapsedMillis & operator -= (unsigned long val)      { ms += val ; return *this; }
    elapsedMillis & operator += (unsigned long val)      { ms -= val ; return *this; }
    elapsedMillis operator - (int val) const           { elapsedMillis r(*this); r.ms += val; return r; }
    elapsedMillis operator - (unsigned int val) const  { elapsedMillis r(*this); r.ms += val; return r; }
    elapsedMillis operator - (long val) const          { elapsedMillis r(*this); r.ms += val; return r; }
    elapsedMillis operator - (unsigned long val) const { elapsedMillis r(*this); r.ms += val; return r; }
    elapsedMillis operator + (int val) const           { elapsedMillis r(*this); r.ms -= val; return r; }
    elapsedMillis operator + (unsigned int val) const  { elapsedMillis r(*this); r.ms -= val; return r; }
    elapsedMillis operator + (long val) const          { elapsedMillis r(*this); r.ms -= val; return r; }
    elapsedMillis operator + (unsigned long val) const { elapsedMillis r(*this); r.ms -= val; return r; }
};

elapsedMillis deathTime, shootTime, reloadTime;

class Laser
{
    uint8_t pin;
    uint16_t time, prevMillis;
    bool state;
public:
    Laser(uint8_t p, uint16_t period)
    {
        pin = p;
        time = interval;
        prevMillis = 0;
        state = true;
    }

    void update()   //updates the output on ir_tx, no other routine is needed to constantly change pin outputs; function is constantly being called in the loop function
    {
        currentMillis = millis();
        if( state && currentMillis - prevMillis > time)
        {
            state = false;
            digitalWrite(ir_tx, LOW);
        }
        else()
        {
            digitalWrite(ir_tx, HIGH);
        }
    }

    void shoot()    //pulling the trigger calls just the shoot function
        state = true;

void reload()
{

    reloadTime = 0;
    display.setCursor(15,7);
    display.setTextSize(1);
    display.println("Reloading...");
    display.display();
    updateRegister();
    delay(2000)
}

void shoot()
{
    if(alive && ammo && (reloadTime > 3000) && (shootTime > 500))   //shoot only if alive and ammo is left and previous shoot happened at least 0.5 seconds ago
    {
        shootTime = 0;
        digitalWrite(ir_tx, HIGH);
        bitWrite(ledStatus, 0, 1);
        updateRegister();
        bitWrite(ledStatus, 0, 0);
        ammo -= 1;
        display.display();
        delay(500);
    }
    if(ammo == 0)
        reload();
}

void hit()
{
    if(alive)
    {

        bitWrite(ledStatus, 2, 1);
        updateRegister();
        health = constrain(health-10, 0, health);
        delay(200);     //give a buffer before second hit is recorded
        bitWrite(ledStatus, 2, 0);
        updateRegister();
        if(!health)
        {
            deathTime = 0;
            alive = 0;
            dead();     //respawn() is called from dead()
        }
    }
    updateScreen();     //update after respawn
}

void dead()
{

    bitWrite(ledStatus, 3, 1);
    bitWrite(ledStatus, 4, 0);
    //still need to confirm whether keeping the register always enabled creates any problems, if yes, edit updateRegister function
    updateRegister();
    display.setCursor(27,7);
    display.setTextSize(6);
    display.println("DEAD");
    bitWrite(ledStatus, 2);
    for(uint8_t i = 5; i > 0; i--)
    {
        display.print("Respawning in... ");
        display.println(i);
        display.display();
        delay(1000);
    }

    bitWrite(ledStatus, 3, 0);
    bitWrite(ledStatus, 4, 1);
    updateRegister();
    respawn();
}

void respawn()      //reset to default values
{
    bitWrite(ledStatus, 3, 0);
    bitWrite(ledStatus, 4, 1);
    updateRegister();
    ammo = 10;
    health = 100;
    alive = true;
}

void updateScreen()
{
    display.setCursor(27,7);    //offset for AMMO in template
    display.setTextSize(1);
    display.println(ammo);
    display.setCursor(15,42);   //offset for HP in template
    display.setTextSize(1);
    display.println(health);
}

void updateRegister()
{
    SPI.beginTransaction();
    SPI.transfer(ledStatus);
    SPI.endTransaction();
}

void setup()
{
    pinMode(sck, OUTPUT);
    pinMode(leds, OUTPUT);
    pinMode(trig, INPUT);
    attachInterrupt(ir_rx, hit(), RISING);
    attachInterrupt(trig, shoot(), RISING);
    SPI.beginTransaction(custom);   //set custom settings once
    SPI.transfer(ledStatus);
    SPI.endTransaction();

}

void loop()
{
    updateRegister();
    laser.update();
    display.display();
}
